# example11-accumulate

どうしてexample10で影がツブツブでチラチラだったのかというと、ごめんなさい、実は私のコードに間違いがあったためなんです。example09のDeviceProgram.cuを見てください。`__raygen__renderFrame()`でサンプリングするループ数である`PIXEL_SAMPLE_SIZE`は16になっているのですけど、`__closesthit__radiance()`でサンプリングするループ数の`LIGHT_SAMPLE_SIZE`は1になっているんですよ。サンプリング数が足りないので、ツブツブでチラチラになってしまったわけですな。

ただ、言い訳をさせてください。`LIGHT_SAMPLE_SIZE`を16とかにすれば、たしかに影がなめらかになって綺麗な画像になります。ただ、その代償として動作が重くなってしまうんですよ。マウスで視点をグリグリしてみると、私の型落ちGPUでは動作があまりにモッサリで辛い……。

というわけで、example11ではちょっとズルをしてサンプリング数を増やしましょう。

さて、カメラが移動しない場合は、生成される画像は同じ（ただし乱数によって微妙に違う）ものになるはずです。というわけで、前回生成された画像と今回生成された画像を足して2で割れば、サンプリング数が2倍になるわけです（カメラが移動した場合は前回生成された画像を使用できないので、サンプリング数は増えませんけど）。じゃあ、過去99枚分の画像を残しておけばサンプリング数は100倍になる……のですけど、メモリの無駄が大きくなってしまうのでそれはちょっと嫌です。

だから、今回がカメラが止まって`n`回目（初回は`n` = 0）の画像の場合は`(前回までで生成された画像 * n + 今回生成された画像) / (n + 1)`してあげることにしましょう。n回目に生成された画像のほうがn + 1回目に生成された画像よりも大きく扱われるので平均ではありませんけど、長い目で見れば概ね平均になるはず。

変更はとても簡単です。DeviceProgram.cuの`__rangen__renderFrame()`に以下の処理を追加するだけ。

~~~c++
// カメラや画面のサイズが変わっていない（frameIdが0ではない==生成している画像が同じ）場合は、これまでの繰り返しで作成したピクセルの色と今回のピクセルの色の平均を取りをします。

if (optixLaunchParams.frameId > 0) {
  result += optixLaunchParams.frameId * *reinterpret_cast<Eigen::Vector3f *>(&optixLaunchParams.imageBuffer[x + y * optixGetLaunchDimensions().x]); // 今回のピクセルの色にこれまでの平均値をframeId（これまでに計算したピクセルの数）倍したものを足し合わせて、
  result /= optixLaunchParams.frameId + 1;                                                                                                          // frameId（これまでに計算したピクセルの数）+ 1（今回計算したピクセルの分）で割ります。
}
~~~

あとは、Renderer.hに、カメラが移動した場合（あと、画像のサイズが変わった場合も）に`frameId_`を初期化する処理を追加するだけです。プログラムを実行して、最初はツブツブでチラチラな画像が段々となめらかになって、気がついたらとても綺麗な画像になっていれば作業は終了です。お疲れさまでした。

![example11-accumulate-linux](https://raw.githubusercontent.com/tail-island/optix7courseR/main/image/example11-accumulate-linux.png)

![example11-accumulate-windows]()

# 終わりに

[元ネタ](https://github.com/ingowald/optix7course)だと、OptiXのノイズ除去機能も紹介しているのですけど、これ、画像が綺麗になった理由の殆どはexample11-accumulateと同じに過去画像との積算をしているためでしかなかったりします。嘘だと思うなら、元ネタのex11_denoiseColorOnlyやex12_denoiseSeparateChannelsを実行した後に、aキーを押して過去画像との積算をする機能を止めてみてください。ほら、細部がぼやけた汚い画像が表示されるだけでしょ？　なので、本コースではOptiXのノイズ除去機能の解説はなしとさせてください。

というわけでこれで本コースは完了なのですけど、実は本コースで解説したのはOptiXの使い方であって、ごめんなさい、レイ・トレーシングのやり方じゃあないんです……。現実の光について考えてみてください。赤い壁に反射した光に照らされた白い壁は、ほんのり赤くなるはずですよね？　あと、散乱光は0.2みたいな毎回同じ値じゃなくて、周囲の環境によって変わるものですよね？　本コースのプログラムでは、これらを全くシミュレートできていません。レイ・トレーシングでは、本コースのプログラムみたいにレイが物体に衝突したらあとは影のレイを考えるだけなんてものではなくて、散乱も考慮した光の反射を逆方向に何度も辿っていくものなんです。しかも、様々な反射があり得るので、1本のレイが反射で複数のレイになるという計算地獄……なのですけど、OptiXで`optxTrace()`をした場合はOptiXがイイ感じにCUDAで並列化してくれるので高速に動作してあぁやっぱりOptiXは素晴らしいなぁというのが、レイ・トレーシングの本来のやり方なんです。

その反射はどんなふうにやれば良いのかを知りたい場合は、[レイトレーシング入門](https://zenn.dev/mebiusbox/books/8d9c42883df9f6)（←無料で読めます）のChapter 03のモンテカルロレイトレーシングが分かりやすくて面白いので、参考にしてください。で、皆様が実装した結果をこのコースに追加していただけないかなぁと……。
